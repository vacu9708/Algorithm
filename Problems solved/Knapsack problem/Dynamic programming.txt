// Finding the biggest profit for a knapsack
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

//void knapsack_ineffective() {
//	int n_of_items = 5, max_weight = 15;
//	int weights[] = { 0,12,1,4,1,2 }; // 무게
//	int values[] = { 0,4,2,10,1,2 }; // 가치
//	vector <vector<int>> memo(n_of_items, vector<int>(max_weight));
//
//	for (int i = 1; i <= n_of_items; i++)
//		for (int j = 1; j <= max_weight; j++)
//			if (j - weights[i] >= 0) // i번째 물건을 넣을 수 있다면?
//				memo[i][j] = max(memo[i - 1][j], memo[i - 1][j - weights[i]] + values[i]); // 넣지 않을 때와 넣었을 때, 둘 중 더 큰 것으로 초기화
//			else // i번째 물건을 넣을 수 없다면, 배낭 용량은 같고 넣지 않았을 때의 값으로 초기화
//				memo[i][j] = memo[i - 1][j];
//
//	cout << memo[n_of_items][max_weight];
//}

void knapsack() {
	int n_of_items = 5, max_weight = 15;

	cin >> n_of_items >> max_weight;

	vector<int> weights = { 12,1,4,1,2 };
	vector<int> values = { 4,2,10,1,2 };
	vector<int> memo(max_weight + 1);

	/*weights.resize(n_of_items);
	values.resize(n_of_items);
	for (int i = 0; i < n_of_items; i++)
		cin >> weights[i] >> values[i];*/

	for (int i = 0; i < n_of_items; i++)
		for (int j = max_weight; j >= 1; j--)
			if (j >= weights[i]) {// 넣을 수 있다면?
				memo[j] = max(memo[j], memo[j - weights[i]] + values[i]);

				for (int i = 0; i < max_weight; i++) // For debugging
					cout << memo[i] << " ";
				cout << "\n";

			}
	 
	//for (int i = 0; i < n_of_items; i++) // Doesn't work
	//	for (int j = 1; j <= max_weight; j++)
	//		if (j >= weights[i]) {// 넣을 수 있다면?
	//			memo[j] = max(memo[j], memo[j - weights[i]] + values[i]);

	//			for (int i = 0; i < max_weight; i++) // For debugging
	//					cout << memo[i] << " ";
	//			cout << "\n";

	//		}

	printf("%d", memo[max_weight]);
}

int main() {
	knapsack();
}