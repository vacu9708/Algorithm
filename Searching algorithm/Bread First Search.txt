-----Using adjacent list
#include <iostream>
#include <vector>
using namespace std;
#define GRAPH_LENGTH 10 // The number of the vertices

void insert_edge(vector<vector<int>>& graph, int start, int end) {
	graph[start].push_back(end);
	graph[end].push_back(start);
}

void print_graph(vector<vector<int>>& graph) {
	for (int i = 0; i < graph.size(); i++) {
		cout << i << " : { ";
		for (int j = 0; j < graph[i].size(); j++)
			cout << graph[i][j] << " ";
		cout << "}\n";
	}
}

int queue[GRAPH_LENGTH] = { 0, };
int front = 0, rear = 0;
void enQ(int data) {
	if ((rear + 1) % GRAPH_LENGTH == front)
		printf("The queue is full.\n");
	else {
		rear = (rear + 1) % GRAPH_LENGTH; // If it's the last index go to index 0, else index++
		queue[rear] = data;
	}
}

int deQ() {
	if (front == rear)
		printf("The queue is empty.\n");
	else {
		front = (front + 1) % GRAPH_LENGTH;
		return queue[front];
	}
}

bool visited[GRAPH_LENGTH] = { false, };
void BFS(vector<vector<int>>& graph, int vertex) {
	visited[vertex] = true; // Visit
	cout << vertex << " -> "; // Print
	enQ(vertex);

	while (front != rear) { // While the queue isn't empty
		vertex = deQ();
		for (auto i : graph[vertex]) // Search for the vertices not visited
			if (!visited[i]) {
				visited[i] = true; // Visit
				cout << i << " -> "; // Print
				enQ(i); // Record the vertices to search from later while searching
			}
	}
}

int main() {
// A : 0 | B : 1 | C : 2 | D : 3 | S : 4
	vector<vector<int>> graph(GRAPH_LENGTH);
	insert_edge(graph, 0, 1);
	insert_edge(graph, 1, 2);
	insert_edge(graph, 1, 3);
	insert_edge(graph, 2, 4);
	insert_edge(graph, 3, 4);
	insert_edge(graph, 3, 5);
	insert_edge(graph, 5, 6);
	insert_edge(graph, 5, 7);
	insert_edge(graph, 6, 7);
	insert_edge(graph, 7, 8);
	insert_edge(graph, 7, 9);
	print_graph(graph);
	BFS(graph, 3);
}

-----Using adjacent matrix
#include <iostream>
using namespace std;

#define GRAPH_LENGTH 10 // The number of the vertices

void insert_edge(int adj_matrix[][GRAPH_LENGTH], int start, int end) {
	adj_matrix[start][end] = 1;
	adj_matrix[end][start] = 1;
}

void print_adj_matrix(int adj_matrix[][GRAPH_LENGTH]) {
	for (int i = 0; i < GRAPH_LENGTH; i++) {
		for (int j = 0; j < GRAPH_LENGTH; j++)
			cout << adj_matrix[i][j] << "  ";
		cout << "\n";
	}
}

int queue[GRAPH_LENGTH] = { 0, };
int front = 0, rear = 0;
void enQ(int data) {
	if ((rear + 1) % GRAPH_LENGTH == front)
		printf("The queue is full.\n");
	else {
		rear = (rear + 1) % GRAPH_LENGTH; // If it's the last index go to index 0, else index++
		queue[rear] = data;
	}
}

int deQ() {
	if (front == rear)
		printf("The queue is empty.\n");
	else {
		front = (front + 1) % GRAPH_LENGTH;
		return queue[front];
	}
}

bool visited[GRAPH_LENGTH] = { false, };
void BFS(int adj_matrix[][GRAPH_LENGTH], int vertex) {
	visited[vertex] = true;
	cout << vertex << " ";
	enQ(vertex);

	while (front != rear) { // While the queue isn't empty
		vertex = deQ();
		for (int i = 0; i < GRAPH_LENGTH; i++)
			if (adj_matrix[vertex][i] && !visited[i]) { // Search for the vertices not visited
				visited[i] = true;
				cout << i << " ";
				enQ(i); // Record the vertices to search from while searching
			}
	}
}

int main() {
	int adj_matrix[GRAPH_LENGTH][GRAPH_LENGTH] = { 0, };
	insert_edge(adj_matrix, 0, 1);
	insert_edge(adj_matrix, 1, 2);
	insert_edge(adj_matrix, 1, 3);
	insert_edge(adj_matrix, 2, 4);
	insert_edge(adj_matrix, 3, 4);
	insert_edge(adj_matrix, 3, 5);
	insert_edge(adj_matrix, 5, 6);
	insert_edge(adj_matrix, 5, 7);
	insert_edge(adj_matrix, 6, 7);
	insert_edge(adj_matrix, 7, 8);
	insert_edge(adj_matrix, 7, 9);
	print_adj_matrix(adj_matrix);
	BFS(adj_matrix, 3);
}