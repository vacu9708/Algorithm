Process : find the maximum >> move the maximum
Take advantage of the fact that the root of a heap is always max(min). 
It's similar to selection sort in that maxima or minima are looked for and then they are moved.
-----Code
#include <iostream>
using namespace std;

void heapify(int* heap_tree, int size, int parent) { // Function to max-heapify the tree
	int largest = parent, left = 2 * parent + 1, right = 2 * parent + 2;
	if (left  < size && heap_tree[left] > heap_tree[largest])
		largest = left;
	if (right < size && heap_tree[right] > heap_tree[largest])
		largest = right;
	// Swap and continue heapifying if parent is not largest
	if (largest != parent) {
		swap(heap_tree[parent], heap_tree[largest]);
		heapify(heap_tree, size, largest);
	}
}

void print_array(int* arr, int length) {
	for (int i = 0; i < length; i++)
		cout << arr[i] << " ";
	cout << "\n";
}

void heapSort(int* arr, int length) {
	for (int i = length / 2 - 1; i >= 0; i--) { // Max-heapify from the last parent ( (child+1) / 2 -1 is its parent)
		heapify(arr, length, i);
		print_array(arr, length); // Show the process
	}
	cout << "-----Max-heap made\n";

	for (int i = length - 1; i > 0; i--) { // Start from the last index
		swap(arr[0], arr[i]); // Move the root which is the biggest value
		cout << "---Swap(with index " << i << ")\n"; // Show the process
		print_array(arr, length);

		heapify(arr, i, 0);
		cout << "---MaxHeapify(last index " << i - 1 << ")\n"; // Show the process
		print_array(arr, length);
	}
}

int main() {
	int heap_tree[] = { 5,4,3,2,1 };
	int size = sizeof(heap_tree) / sizeof(int);
	heapSort(heap_tree, size);
}
