// Finding the minimum number of coins needed to make target_money
// Dynamic programming (The solution is always the most efficient)

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 987654321;
int memo[100001];
int target_money = 15, n_of_coin_type = 2;
vector<int> coins = { 5, 2 };

//int solution_recursion(int target_money) { // Works well but ineffective
//	if (target_money == 2 || target_money == 5)
//		return 1;
//	if (target_money == 0)
//		return 0;
//	if (target_money < 2)
//		return INF;
//
//	return min(solution(target_money - 2), solution(target_money - 5)) + 1;
//}

void solution(int target_money) {
	// Initialization
	for (int i = 0; i <= target_money; i++)
		memo[i] = INF;
	memo[0] = 0, memo[2] = 1, memo[5] = 1;
	//-----

	for (int i = 0; i < coins.size(); i++)
		for (int j = coins[i]; j <= target_money; j++) {
			memo[j] = min(memo[j], memo[j - coins[i]] + 1);

			for (int i = 0; i <= target_money; i++) // For debugging
				cout << memo[i] << " ";
			cout << "\n";
		}

	//for (int i = 0; i < coins.size(); i++) // Doesn't work
	//	for (int j = target_money; j >= coins[i]; j--) {
	//		memo[j] = min(memo[j], memo[j - coins[i]] + 1);
	//			
	//		for (int i = 0; i <= target_money; i++) // For debugging
	//			cout << memo[i] << " ";
	//		cout << "\n";
	//	}
}

int main() {
	/* Manual input
	cin >> target_money;
	cin >> n_of_coin_type;
	for (int i = 0; i < n_of_coin_type; i++)
		cin >> coins[i];*/

	solution(target_money);
	printf("%d", memo[target_money] == INF ? -1 : memo[target_money]);

	//int answer = solution(target_money); // Recursvie solution
	//printf("%d", answer == INF + 1 ? -1 : answer);
}