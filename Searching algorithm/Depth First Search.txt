-----Using adjacent list
#include <iostream>
#include <vector>
using namespace std;

const char GRAPH_SIZE = 10;
vector<vector<int>> graph(GRAPH_SIZE);

void add_edge(int start, int end) {
	graph[start].push_back(end);
	graph[end].push_back(start);
}

vector<bool> visited(GRAPH_SIZE, false);
void DFS(int vertex) {
	visited[vertex] = true; // Visit
	cout << vertex << " -> ";

	for (auto i : graph[vertex]) // Search for the vertices not visited
		if (!visited[i])
			DFS(i);
}

int main() {
	add_edge(0, 1);
	add_edge(1, 2);
	add_edge(1, 3);
	add_edge(2, 4);
	add_edge(3, 4);
	add_edge(3, 5);
	add_edge(5, 6);
	add_edge(5, 7);
	add_edge(6, 7);
	add_edge(7, 8);
	add_edge(7, 9);
	cout << "Searchng : ";
	DFS(3);
}

-----Using adjacent matrix
#include <iostream>
using namespace std;

const char GRAPH_SIZE GRAPH_LENGTH 10 // The number of the vertices
bool adj_matrix[GRAPH_LENGTH][GRAPH_LENGTH] = { 0, };

void add_edge(int start, int end) {
	adj_matrix[start][end] = 1;
	adj_matrix[end][start] = 1;
}

void print_adj_matrix() {
	for (int i = 0; i < GRAPH_SIZE; i++) {
		for (int j = 0; j < GRAPH_SIZE; j++)
			cout << adj_matrix[i][j] << "  ";
		cout << "\n";
	}
}

bool visited[GRAPH_LENGTH] = { false, };

void DFS(int vertex) {
	visited[vertex] = true; // Visit
	cout << vertex << " ";

	for (int i = 0; i < GRAPH_SIZE; i++)
		if (adj_matrix[vertex][i] && !visited[i]) // Search for the vertices not visited
			DFS(adj_matrix, i);
}

int main() {
	add_edge(0, 1);
	add_edge(1, 2);
	add_edge(1, 3);
	add_edge(2, 4);
	add_edge(3, 4);
	add_edge(3, 5);
	add_edge(5, 6);
	add_edge(5, 7);
	add_edge(6, 7);
	add_edge(7, 8);
	add_edge(7, 9);
	print_adj_matrix();
	DFS( 3);
}

-----Python
graph = [
    [1],
    [0, 2, 3],
    [1, 4],
    [1, 4, 5],
    [2, 3],
    [3, 6, 7],
    [5, 7],
    [5, 6 ,8, 9],
    [7],
    [7]
]
visited=[False]*10

def dfs1(vertex):
    visited[vertex]=True
    print(vertex, end=' ')
    for i in graph[vertex]:
        if not visited[i]:
            dfs1(i)

def dfs2(vertex):
    visited[vertex]=True
    print(vertex, end=' ')
    for i in range(len(graph[vertex])):
        if not visited[graph[vertex][i]]:
            dfs2(graph[vertex][i])

dfs1(3)

-----
#dictionary와 set 자료형 (set은 순서가 상관이 없기 때문에 방문 순서가 바뀔 수 있다.)
graph = {'A' : set(['B', 'C']), 
         'B' : set(['A', 'D', 'E']),
         'C' : set(['A', 'F']),
         'D' : set(['B']),
         'E' : set(['B', 'F']),
         'F' : set(['C', 'E'])}
visited = []

def dfs_recursive(vertex):
    if vertex not in visited: #방문하지 않았으면
        visited.append(vertex) #visit
        for node in graph[vertex].difference(visited): #현재 노드에 연결된 노드에서 visited에 있는거 제외하고
            dfs_recursive(node, visited)
    return visited

print(dfs_recursive('A'))