// Finding the biggest profit when putting items in a knapsack

#include <iostream>
#include <vector>

using namespace std;

int how_many_items = 5, max_weight = 15, biggest_profit = 0;
vector<bool> truth_table(how_many_items), answer(how_many_items);
vector<int> item_weights = { 12, 1, 4, 1, 2 }; // kg
vector<int> item_values = { 4, 2, 10, 1, 2 }; // $

void knapsack_backtracking(int level, int sum_of_weights, int sum_of_values) { // level : Level of tree
	if (level == how_many_items) { // The last level of tree : having checked all the items, so termination
		if (sum_of_values > biggest_profit) { // Update answer
			biggest_profit = sum_of_values;
			for (int i = 0; i < how_many_items; i++)
				answer[i] = truth_table[i];
		}

		return;
	}

	for (int i = 0; i <= 1; i++) { // (DFS on a tree)
		truth_table[level] = i;

		if (i == 1) {
			if (sum_of_weights + item_weights[level] > max_weight) // If the sum of weights exceeds max weight, cut the branch for backtracking
				return;
			// Save the information upto the previous cases in the parameters
			knapsack_backtracking(level + 1, sum_of_weights + item_weights[level], sum_of_values + item_values[level]);
		}
		else
			knapsack_backtracking(level + 1, sum_of_weights, sum_of_values);
	}
}

void print_answer() {
	printf("A B C D E\n");
	for (int i = 0; i < how_many_items; i++)
		printf("%d ", answer[i] == true ? 1 : 0);
	printf("/ Biggest profit : %d\n", biggest_profit);

}

int main() {
	/* Putting values for the varaibles manually
	cin >> how_many_items >> max_weight;
	item_weights.resize(how_many_items);
	item_values.resize(how_many_items);
	for (int i = 0; i < how_many_items; i++)
		cin >> item_weights[i] >> item_values[i];*/

	knapsack_backtracking(0, 0, 0);
	print_answer();
}