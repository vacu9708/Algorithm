Quick sort is the most effective sorting algorithm but it has a disadvantage that it can't preserve the elements with the same value.

// To change it to descending order
while (i < right && array[i] >= array[pivot_index])
            i++;
        while (j > pivot_index && array[j] <= array[pivot_index])
            j--;

-----Code
#include <iostream>
using namespace std;

void print_array(int* arr, int length) {
    for (int i = 0; i < length; i++)
        cout << arr[i] << " ";
    cout << "\n";
}

void quick_sort(int* arr, int left, int right) {
    if (left < right) { // While the length is not 1 (base case of recursion)
        int pivot_index = left; // Any index can be pivot
        int i = pivot_index + 1, j = right;
        while (1) {
            while (i < right && arr[i] <= arr[pivot_index]) // To find element bigger than pivot
                i++;
            while (j > pivot_index && arr[j] >= arr[pivot_index]) // To find element smaller than pivot
                j--;
            if (j > i)
                swap(arr[j], arr[i]);
            if (j <= i) { // If finding arr[j] less than pivot in (j > i) is failed (엇갈림)
                swap(arr[j], arr[pivot_index]);
                break;
            }
        }
    }
    // Now j is a new pivot
    quick_sort(arr, left, j - 1); // recursive call on the left of pivot
    quick_sort(arr, j + 1, right); // right side of pivot
}

void main() {
    int arr[] = { 5,4,5,3,2,1 };
    int length = sizeof(arr) / sizeof(int);
    quick_sort(arr, 0, length - 1);
    print_array(arr, length);
}